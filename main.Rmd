
---
title: "main.r"
author: "JohnHadish"
date: "3/8/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Testing The Program:
Each Function should have its own demonstration script: 

Download Data:
```{r}
myGenotype=read.table(file="http://zzlab.net/GAPIT/data/mdp_numeric.txt",head=T)
myPosition=read.table(file="http://zzlab.net/GAPIT/data/mdp_SNP_information.txt",head=T)
myPhenotype=read.table(file="http://zzlab.net/GAPIT/data/CROP545_Phenotype.txt",head=T)
myCovariate=read.table(file="http://zzlab.net/GAPIT/data/CROP545_Covariates.txt",head=T)
```

```{r}
library(plotly)
library(ggplot2)
library(gridExtra)
library(knitr)

```

Description: 
returns: P: a vector n long of p values for every gene in n
Dependent: Generate_PCA, Scree, Determine_Linear_Dependent
```{r, Run_GLM}
# prcomp is a default principle component analysis
allPC <- prcomp(myGenotype[,-1])
# pcThreshold removes all princople components that account for less than threshold
threshPC <- pcThreshold(allPC)





# pcCovariance  determines if covariates are linear with principle components
finalPC <- pcCoVariance(threshPC, myCovariate, .7)

Run_GLM(myGenotype, myPhenotype[,2], finalPC)
```

returns: principal components after scree analysis
```{r, Determine_PC_Number}

myGD = myGenotype[,-1]
y = myPhenotype[,2]
PC = finalPC
i = 1

n=nrow(X)
m=ncol(X)
P=matrix(NA,1,m)
# Loop through each column
  
  G=myGD[,-1]
  n=nrow(G)
  m=ncol(G)
  P=matrix(NA,1,m)
  for (i in 1:m){
    x=G[,i]
    if(max(x)==min(x)){
      p=1}else{
        X=cbind(1, PC[,1:3],x)
        typeof(X)
        typeof(t(t(X)))
        
            a = (PCA$x[,1:8])
        typeof(a)
        
        typeof(PC)
        PC2 = PC
        
        PC3 = unlist(PC2)
        typeof(PC3)
        
        
        
        
        
        LHS=t(X)%*%X
        C=solve(LHS)
        RHS=t(X)%*%y
        b=C%*%RHS
        yb=X%*%b
        e=y-yb
        n=length(y)
        ve=sum(e^2)/(n-1)
        vt=C*ve
        t=b/sqrt(diag(vt))
        p=2*(1-pt(abs(t),n-2))
      } #end of testing variation
    P[i]=p[length(p)]





```


returns: unknown
```{r, Determine_linear_dependent}

Determine_Linear_Dependent(PC, C)
```



Returns: a QQ plot of observed and expected p values
```{r, Plot_QQ}
Plot_QQ(P)
```

Returnes: Manhatten plot
```{r, Plot_ Manhatten}
Plot_Manhatten(I, P)
```

P_Threshold
returns: how many true positives are above the first false positive
```{r}
```

